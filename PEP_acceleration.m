function selectedEnsemble=PEP(n,f,eval)
%%  ATTN
%   ATTN: This package is free for academic usage. You can run it at your
%   own risk. For other purposes, please contact Prof. Zhi-Hua Zhou (zhouzh@nju.edu.cn)
%%  ATTN2
%   ATTN2: This package was developed by Mr. Chao Qian (qianc@lamda.nju.edu.cn). For any problem concerning the code,
%        please feel free to contact Mr. Qian.
%%  Some varables used in the code
%   input: 
%      NOTE THAT we use a Boolean string "1001....1100" to represent a subset of trained base learners, where "1" means that the corresponding base learner is selected, and "0" means ignoring the learner.
%      n: the total number of trained base learners. 
%      f: an objective function relating to the generalization performance; its input should be a subset of base learners, i.e., a Boolean string of length n; its output should be a real value.
%      eval: an evaluation function to select the final subEnsemble; its input should be a subset of base learners, i.e., a Boolean string of length n; its output should be a real value.
%      NOTE THAT we assume that both f and eval are to be minimized.
%   ouptut: 
%      selectedEnsemble: a Boolean string of length n representing the selected subset of base learners. 


    %initialize the candidate solution set (called "population"): randomly generate a Boolean string of length n (called "solution").
    population=randsrc(1,n,[0,1]);
    %popSize: record the number of solutions in the population.
    popSize=1;
    %fitness: record the two objective values of a solution, the first objective is f and the second one is the number of learners, i.e., the sum of all the bits.
    fitness=zeros(1,2);
    fitness(2)= sum(population);
    if fitness(2)==0
        %for the special solution 00...00 (i.e., it does not select any learner), set its first objective value as inf.  
        fitness(1)=inf;
    else
        fitness(1)= f(population);
    end

    %repeat to improve the population; the number of iterations is set as n^2 log(n) suggested by our theoretical analysis.
    T=round(n^2*log(n));
%     disp(T)
    for i=1:T
%         disp(i)
        %randomly select a solution from the population and mutate it to generate a new solution.
%         offspring=abs(population(randint(1,1,[1,popSize]),:)-randsrc(1,n,[1,0; 1/n,1-1/n]));
        offspring=abs(population(randi([1,popSize],1,1),:)-randsrc(1,n,[1,0; 1/n,1-1/n]));
        %computer the fitness of the new solution.
        offspringFit=zeros(1,2);
        offspringFit(2)= sum(offspring);
        if offspringFit(2)==0
            offspringFit(1)=inf;
        else
            offspringFit(1)= f(offspring);
        end

        % use the new solution to update the current population.            
        if sum((fitness(1:popSize,1)<offspringFit(1)).*(fitness(1:popSize,2)<=offspringFit(2)))+sum((fitness(1:popSize,1)<=offspringFit(1)).*(fitness(1:popSize,2)<offspringFit(2)))>0
            continue;
        else
            deleteIndex=((fitness(1:popSize,1)>=offspringFit(1)).*(fitness(1:popSize,2)>=offspringFit(2)))'; 
        end
        % ndelete: record the index of the solutions to be kept.
        ndelete=find(deleteIndex==0);
        population=[population(ndelete,:)',offspring']';
        fitness=[fitness(ndelete,:)',offspringFit']';          
        popSize=length(ndelete)+1;

        % VDS subroutine: bestSolution: record the solution with the best f; bestFitness: record the corresponding fitness values. 
        bestSolution=zeros(1,n);        
        bestFitness=[inf,inf];
        isChanged=zeros(1,n);
        for j=1:n
            % hammingSolutions: all the hamming neighbor solutions.
            hammingSolutions=repmat(offspring,n-j+1,1);
            hammingFValues=zeros(1,n-j+1);
            temp=find(isChanged==0);
            for p=1:n-j+1
                 hammingSolutions(p,temp(p))=1-hammingSolutions(p,temp(p));
                 hammingFValues(p)=f(hammingSolutions(p,:));
            end
            hammingFValues(sum(hammingSolutions,2)==0)=inf;
            
            % update the solution with the best f.
            [bestF,bestPos]=min(hammingFValues);
            bestS=sum(hammingSolutions(bestPos,:));
            if bestF<bestFitness(1)
                bestSolution=hammingSolutions(bestPos,:);
                bestFitness=[bestF,bestS];
            elseif sum([bestF,bestS]<=bestFitness)==2
                bestSolution=hammingSolutions(bestPos,:);
                bestFitness=[bestF,bestS];
            end
            
            %record the changed position.
            isChanged(find(offspring~=hammingSolutions(bestPos,:)))=1;
            offspring=hammingSolutions(bestPos,:);
        end

        % use the solution generated by VDS to update the current population. 
        if sum((fitness(1:popSize,1)<bestFitness(1)).*(fitness(1:popSize,2)<=bestFitness(2)))+sum((fitness(1:popSize,1)<=bestFitness(1)).*(fitness(1:popSize,2)<bestFitness(2)))>0
            continue;
        else
            deleteIndex=((fitness(1:popSize,1)>=bestFitness(1)).*(fitness(1:popSize,2)>=bestFitness(2)))'; 
        end      
        ndelete=find(deleteIndex==0);
        population=[population(ndelete,:)',bestSolution']';
        fitness=[fitness(ndelete,:)',bestFitness']';      
        popSize=length(ndelete)+1; 
    end
    
    % select the final solution according to the eval function 
    evalValue=zeros(1:popSize);
    for i=1:popSize
        evalValue(i)=eval(population(i,:));
    end
    [~,index]=min(evalValue);
    selectedEnsemble=population(index,:);
end